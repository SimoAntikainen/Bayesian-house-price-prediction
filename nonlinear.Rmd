---
title: "nonlinear"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Introduction

(motivate the problem and )


https://www.kaggle.com/harlfoxem/housesalesprediction



# 2. Dataset description

```{r}
library(rstan)
options(mc.cores = 4)#parallel::detectCores())
library(ggplot2)
library(matrixStats)
library(dplyr)
library(GGally)
library(corrplot)
library(reshape2)

library(ElemStatLearn)
library(glmnet)
library(plotmo)

library(Metrics)

```



```{r}
houseprice = read.csv("data/kc_house_data.csv", header = TRUE)
houseprice$log_price = log(houseprice$price)
datecol <- as.POSIXct(houseprice$date, format="%Y%m%dT%H%M%S")
houseprice$date_num = as.numeric(datecol)
unique_zips = unique(houseprice$zipcode)
houseprice$mutated_zipcode = match(houseprice$zipcode,  unique_zips)
head(houseprice)
```

```{r}
#https://stats.stackexchange.com/questions/8071/how-to-choose-between-pearson-and-spearman-correlation
#houseprice = houseprice[,3:21]
M <- cor(houseprice[-2], method="pearson")
corrplot(M, method = "circle")
```




```{r}
M <- cor(houseprice[-2], method="spearman")
corrplot(M, method = "circle")
```

```{r}
# wow this slow
M <- cor(houseprice[3:8], method="kendall")
corrplot(M, method = "circle")
```




```{r}
#ggpairs(houseprice  %>% select(price, bathrooms, sqft_living))
#houseprice_zipped <- houseprice
#houseprice_zipped$zipcode <- as.factor(houseprice_zipped$zipcode)
#ggpairs(houseprice_zipped, columns = c(1,2,3,4), ggplot2::aes(colour=zipcode)) 
ggpairs(houseprice  %>% select(price, bathrooms, sqft_living, grade, sqft_above, sqft_living15))
#ggpairs(houseprice, columns = c("log_price", "bathrooms"), ggplot2::aes(colour=factor(as.integer(lat*20)), alpha=0.75)) 
```

# 3. Model description


## 3.1 Prior choices

(these are good priors because referece to something)


```{r}
hist(houseprice$price)
hist(houseprice$log_price)
hist(houseprice$bathrooms)
hist(houseprice$sqft_living)
hist(houseprice$grade)
hist(houseprice$sqft_living15)
```

## 3.2 Stan models

```{r}

cat(readLines('models/multiple_linear.stan'), sep='\n')
```


```{r}
# scale the columns to 0 mean and 1 sd
houseprice_scaled <- mutate_if(houseprice, is.numeric, list(~scale(.) %>% as.vector))
#colMeans(select_if(houseprice_scaled, is.numeric)) # the means are not exactly 0 but close
#sapply(select_if(houseprice_scaled, is.numeric), sd)
#head(houseprice_scaled)
#usable_numeric_columns = c("date_num", "lat", "long", "yr_built", "sqft_basement", "sqft_above", "grade", "condition", "view", "waterfront", #"floors", "sqft_lot", "sqft_living", "bathrooms", "bedrooms")


usable_numeric_columns = c("date_num", "lat", "long", "yr_built", "grade", "condition", "view", "waterfront", "floors", "sqft_lot", "sqft_living", "bathrooms", "bedrooms")

#usable_numeric_columns = c("sqft_living", "grade","lat")


```

```{r}
training_indices = 0:1000
testing_indices = 1001:1200

used_columns = usable_numeric_columns
target_column = c("log_price")
group_column =  c("mutated_zipcode")
original_target = houseprice[,target_column]
training_data = houseprice_scaled[training_indices,used_columns]
testing_data =  houseprice_scaled[testing_indices, used_columns]
training_target = houseprice_scaled[training_indices,target_column]
testing_target_scaled =  houseprice_scaled[testing_indices, target_column]
testing_target =  houseprice[testing_indices, target_column]

X_var = training_data
X_var_pred = testing_data
y_var = training_target
group_var = houseprice[training_indices,group_column]
group_var_pred = houseprice[testing_indices,group_column]
  
data_list = list(
  X = X_var,
  X_pred = X_var_pred,
  K = ncol(X_var),
  N = nrow(X_var),
  N_pred = nrow(X_var_pred),
  N_groups = length(unique_zips),
  y = y_var,
  groups = group_var,
  groups_pred  = group_var_pred
)
head(X_var)
```


```{r}
multiple_linear_fit <- stan(file = 'models/grouped_multiple_linear.stan', data = data_list)
```

```{r}
print(multiple_linear_fit)
```


```{r}
denormalize_results <- function(new_values, sd, mean){
  return (new_values * sd + mean)
}
```

```{r}
predicted_draws = extract(multiple_linear_fit)$y_pred
predicted_raws = colQuantiles(predicted_draws, probs = c(0.05, 0.5, 0.95))
predicted_prices = denormalize_results(predicted_raws, sd(original_target), mean(original_target))
```


```{r}
result_testing = data.frame(price = testing_target, predicted = predicted_prices)
ggpairs(result_testing, columns = c("price", "predicted.50."))#, #ggplot2::aes(colour=factor(as.integer(lat*20)), alpha=0.75)) 
```
```{r}
library(Metrics)
mae(exp(testing_target),exp(predicted_prices))
```



### Multiple polynomial

```{r}
X_var_second = X_var^2
X_var_pred_second = X_var_pred^2

data_list = list(
  X = X_var,
  X_second = X_var_second,
  X_pred = X_var_pred,
  X_pred_second = X_var_pred_second,
  K = ncol(X_var),
  N = nrow(X_var),
  N_pred = nrow(X_var_pred),
  N_groups = length(unique_zips),
  y = y_var,
  groups = group_var,
  groups_pred  = group_var_pred
)
```




```{r}
multiple_polynomial_fit <- stan(file = 'models/grouped_multiple_polynomial.stan', data = data_list)
```



```{r}
print(multiple_polynomial_fit)
```


```{r}
predicted_draws = extract(multiple_polynomial_fit)$y_pred
predicted_raws = colQuantiles(predicted_draws, probs = c(0.05, 0.5, 0.95))
predicted_prices = denormalize_results(predicted_raws, sd(original_target), mean(original_target))
```


```{r}
result_testing = data.frame(price = testing_target, predicted = predicted_prices)
ggpairs(result_testing, columns = c("price", "predicted.50."))#, #ggplot2::aes(colour=factor(as.integer(lat*20)), alpha=0.75)) 
```


```{r}
library(Metrics)
mae(exp(testing_target),exp(predicted_prices))
```





## 3.3 Running the model

(amount of chains etc and the final fit)





# 4. Convergences diagnostics


# 5. Posterior predictive checking



# 6. Model comparison


# 7. Predictive performance assesment


# 8. Sensitivity analysis



# 9. Discussion







```{R}
library(ElemStatLearn)
library(glmnet)
library(plotmo)


ridge_galaxy <- glmnet(as.matrix(training_data), as.matrix(training_target), alpha = 1)
plot_glmnet(ridge_galaxy, xvar = "lambda", label = TRUE)








```










```{r}
houseprice = read.csv("data/kc_house_data.csv", header = TRUE)
head(houseprice)

```




```{r}
houseprice = houseprice[,3:21]
houseprice <- subset(houseprice, select = -c(sqft_above, sqft_basement))


```

```{r}
M <- cor(houseprice, method="pearson")
corrplot(M, method = "circle")
```


```{r}
full.model <- lm(price ~., data = houseprice)

# Fit the full model 
step.model <- stepAIC(full.model, direction = "forward", 
                      trace = TRUE)
# Stepwise regression model
#summary(step.model)

```








